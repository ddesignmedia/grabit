<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Grab it</title>
    <style>
        /* --- Start: Ersetzungen f√ºr Tailwind CSS & Google Fonts --- */

        /* Ersetzt Tailwind-Klassen auf dem Body-Element und die Google Font "Inter" */
        body {
            font-family: Arial, Helvetica, sans-serif; /* Standard-Schriftart anstelle von Google Font */
            overscroll-behavior: none;
            touch-action: manipulation;
            background-color: #f7fafc; /* Ersetzt bg-gray-100 */
            height: 100vh; /* Ersetzt h-screen */
            overflow: hidden; /* Ersetzt overflow-hidden */
            position: relative; /* Ersetzt relative */
            margin: 0;
            padding: 0;
        }

        /* Ersetzt die Tailwind-Klasse "hidden" */
        .hidden {
            display: none;
        }

        /* Stile f√ºr die Namensanzeige, die vorher von Tailwind kamen */
        #salt-name-display {
            position: absolute;
            top: 1.25rem; /* 20px */
            left: 50%;
            transform: translateX(-50%);
            background-color: white;
            padding: 0.75rem; /* 12px */
            border-radius: 0.5rem; /* 8px */
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            font-weight: bold;
            text-align: center;
            min-width: 250px;
            font-size: 2.5rem;
        }

        /* Stile f√ºr den Spielbereich, die vorher von Tailwind kamen */
        #game-area {
            height: 100%;
            width: 100%;
            position: relative;
        }
        
        /* Stile f√ºr den Hand-Container, die vorher von Tailwind kamen */
        #hands-container {
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            left: 0;
        }
        
        /* Stile f√ºr die Start-Fehlermeldung, die vorher von Tailwind kamen */
        #start-error-message {
            color: #f87171; /* text-red-400 */
            margin-top: 1rem; /* mt-4 */
            font-weight: 600; /* font-semibold */
        }

        /* --- Ende: Ersetzungen f√ºr Tailwind CSS & Google Fonts --- */


        /* Globale Stile & Spiel-Elemente */
        .hand { width: 160px; height: 160px; background-color: #f0f0f0; border: 2px solid #ccc; border-radius: 50%; display: flex; justify-content: center; align-items: center; font-size: 80px; cursor: pointer; position: absolute; transition: transform 0.2s ease-out, background-color 0.2s ease-out; user-select: none; -webkit-user-select: none; -webkit-tap-highlight-color: transparent; }
        .hand-tl { top: 5%; left: 5%; }
        .hand-tr { top: 5%; right: 5%; }
        .hand-bl { bottom: 8%; left: 5%; }
        .hand-br { bottom: 8%; right: 5%; }
        .hand-single { bottom: 8%; left: 50%; transform: translateX(-50%); }


        .card { width: auto; min-width: 200px; min-height: 100px; background-color: white; border: 2px solid #333; border-radius: 10px; display: flex; justify-content: center; align-items: center; font-size: 2.5rem; font-weight: bold; text-align: center; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); padding: 15px 20px; box-shadow: 0 4px 8px rgba(0,0,0,0.1); visibility: hidden; opacity: 0; transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out; }
        .card sub { line-height: 0; position: relative; vertical-align: baseline; top: 0.3em; }
        .card.visible { visibility: visible; opacity: 1; }

        .grabbing { background-color: #a0aec0; z-index: 10; }
        .hand-tl.grabbing { transform: translate(calc(50vw - 80px - 5vw), calc(50vh - 80px - 5vh)); }
        .hand-tr.grabbing { transform: translate(calc(-50vw + 80px + 5vw), calc(50vh - 80px - 5vh)); }
        .hand-bl.grabbing { transform: translate(calc(50vw - 80px - 5vw), calc(-50vh + 80px + 8vh)); }
        .hand-br.grabbing { transform: translate(calc(-50vw + 80px + 5vw), calc(-50vh + 80px + 8vh)); }
        .hand-single.grabbing { transform: translate(-50%, calc(-50vh + 80px + 8vh)); }


        .message-box { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(0, 0, 0, 0.7); color: white; padding: 15px; border-radius: 50%; width: 80px; height: 80px; display: none; justify-content: center; align-items: center; font-size: 40px; z-index: 100; }

        /* Punkteanzeige */
        .player-score { position: absolute; background-color: rgba(255, 255, 255, 0.9); color: #333; padding: 10px 15px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); font-size: 1.8em; font-weight: bold; min-width: 120px; text-align: center; z-index: 5; }
        .score-tl { top: calc(5% + 160px + 10px); left: 5%; }
        .score-tr { top: calc(5% + 160px + 10px); right: 5%; }
        .score-bl { bottom: calc(8% + 160px + 10px); left: 5%; }
        .score-br { bottom: calc(8% + 160px + 10px); right: 5%; }
        .score-single { bottom: calc(8% + 160px + 10px); left: 50%; transform: translateX(-50%); }


        /* Startbildschirm */
        #start-screen { display: flex; flex-direction: column; justify-content: center; align-items: center; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); z-index: 200; color: white; text-align: center; padding: 20px; }
        #start-screen h1 { font-size: 6rem; font-weight: bold; margin-bottom: 1rem; text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3); }
        #start-screen p { font-size: 1.25rem; margin-bottom: 1rem; }

        /* Styling f√ºr Themenauswahl */
        #topic-selection { background-color: rgba(255, 255, 255, 0.1); padding: 15px; border-radius: 10px; margin-bottom: 1.5rem; max-width: 90%; width: 400px; }
        #topic-selection h3 { font-size: 1.65rem; font-weight: bold; margin-bottom: 10px; color: #eee; }
        .topic-item { display: flex; align-items: center; margin-bottom: 8px; cursor: pointer; }
        .topic-item input[type="checkbox"] { margin-right: 10px; width: 18px; height: 18px; cursor: pointer; accent-color: #764ba2; }
        .topic-item label { font-size: 1rem; color: #f0f0f0; flex-grow: 1; cursor: pointer; }
        .topic-item label small { color: #ccc; font-size: 0.85em; margin-left: 5px; }

        #start-screen button { background-color: rgba(255, 255, 255, 0.2); color: white; padding: 15px 30px; border: 1px solid rgba(255, 255, 255, 0.5); border-radius: 12px; font-size: 1.1em; cursor: pointer; margin: 5px; transition: background-color 0.3s, transform 0.1s; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); }
        #start-screen button:hover { background-color: rgba(255, 255, 255, 0.3); }
        #start-screen button:active { transform: scale(0.98); }

        /* Endbildschirm */
        #end-screen { display: none; flex-direction: column; justify-content: center; align-items: center; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(135deg, #434343 0%, #000000 100%); z-index: 150; color: white; text-align: center; padding: 20px; box-sizing: border-box; }
        #end-screen h2 { font-size: 2.5rem; font-weight: bold; margin-bottom: 1rem; color: #ffd700; text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.5); }
        #podium-container { display: flex; justify-content: center; align-items: flex-end; width: 90%; max-width: 500px; height: 250px; margin-bottom: 2rem; gap: 5px; }
        .podium-place { display: flex; flex-direction: column; justify-content: flex-end; align-items: center; flex-grow: 1; border-radius: 8px 8px 0 0; padding: 15px 10px; box-shadow: inset 0 -5px 10px rgba(0,0,0,0.2); text-align: center; color: #333; font-weight: bold; overflow: hidden; transition: height 0.5s ease-in-out; }
        .podium-place .player-name { font-size: 1.1em; margin-bottom: 5px; word-break: break-word; }
        .podium-place .player-score-final { font-size: 1em; }
        .podium-place .crown { font-size: 1.8em; line-height: 1; margin-bottom: 5px; color: #ffd700; }
        .podium-rank-1 { height: 100%; background-color: #ffd700; order: 2; }
        .podium-rank-2 { height: 75%; background-color: #c0c0c0; order: 1; }
        .podium-rank-3 { height: 60%; background-color: #cd7f32; order: 3; }
        .podium-empty { height: 0%; background-color: transparent; box-shadow: none; border: none; padding: 0; }
        #single-player-result { display: none; font-size: 1.8rem; margin-bottom: 2rem; padding: 20px; background-color: rgba(255, 255, 255, 0.1); border-radius: 10px; }
        #end-screen button { background-color: #4CAF50; color: white; padding: 12px 25px; border: none; border-radius: 8px; font-size: 1.1em; cursor: pointer; margin-top: 10px; transition: background-color 0.3s, transform 0.1s; box-shadow: 0 2px 5px rgba(0,0,0,0.2); }
        #end-screen button:hover { background-color: #45a049; }
        #end-screen button:active { transform: scale(0.98); }

        /* Rundenanzeige */
        #round-display {
            position: absolute;
            top: 12%;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(255, 255, 255, 0.8);
            padding: 8px 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            font-size: 1.35em;
            font-weight: bold;
            color: #333;
            z-index: 5;
        }

        * { touch-action: manipulation; }
    </style>
    <!-- Externe Quellen (Google Fonts, Tailwind) wurden entfernt, um DSGVO-konform zu sein -->
</head>
<body>

    <div id="start-screen">
        <h1>Grab it</h1>
        <div id="topic-selection">
            <h3>Themen ausw√§hlen:</h3>
            <div class="topic-item"> <input type="checkbox" id="topic-salts" value="salts" checked> <label for="topic-salts">Salze <small>(Bsp. NaCl)</small></label> </div>
            <div class="topic-item"> <input type="checkbox" id="topic-molecular" value="molecular" checked> <label for="topic-molecular">Molekulare Verbindungen <small>(Bsp. CO‚ÇÇ)</small></label> </div>
            <div class="topic-item"> <input type="checkbox" id="topic-acidsbases" value="acidsbases" checked> <label for="topic-acidsbases">S√§uren & Basen <small>(Bsp. HCl, NaOH)</small></label> </div>
            <div class="topic-item"> <input type="checkbox" id="topic-organic" value="organic" checked> <label for="topic-organic">Organische Verbindungen <small>(Bsp. CH‚ÇÑ)</small></label> </div>
        </div>
        <p>Anzahl der Spieler w√§hlen:</p>
        <div>
            <button onclick="startGame(1)">1 Spieler</button>
            <button onclick="startGame(2)">2 Spieler</button>
            <button onclick="startGame(3)">3 Spieler</button>
            <button onclick="startGame(4)">4 Spieler</button>
        </div>
        <!-- Tailwind-Klassen wurden durch die ID #start-error-message im CSS ersetzt -->
        <p id="start-error-message" class="hidden"></p>
    </div>

    <!-- Tailwind-Klassen wurden durch die ID #game-area im CSS ersetzt -->
    <div id="game-area" class="hidden">
        <!-- Tailwind-Klassen wurden durch die ID #salt-name-display im CSS ersetzt -->
        <div id="salt-name-display">Warte auf Start...</div>
        <!-- Tailwind-Klassen wurden durch die ID #hands-container im CSS ersetzt -->
        <div id="hands-container"></div>
        <div id="card" class="card">Formel</div>
        <div id="round-display"> Runde: 0 / 10 </div>
    </div>

    <div id="message-box" class="message-box"></div>

    <div id="end-screen">
        <h2>And the winner is‚Ä¶</h2>
        <div id="podium-container"></div>
        <div id="single-player-result"></div>
        <button onclick="restartGame()">Nochmal spielen</button>
    </div>

    <script>
        // --- Strukturierte Daten f√ºr chemische Verbindungen ---
        const compoundData = {
            salts: `Natriumchlorid (NaCl), Natriumoxid (Na‚ÇÇO), Natriumbromid (NaBr), Natriumsulfid (Na‚ÇÇS), Natriumsulfat (Na‚ÇÇSO‚ÇÑ), Natriumnitrat (NaNO‚ÇÉ), Kaliumphosphat (K‚ÇÉPO‚ÇÑ), Kaliumnitrit (KNO‚ÇÇ), Magnesiumchlorid (MgCl‚ÇÇ), Magnesiumoxid (MgO), Magnesiumsulfat (MgSO‚ÇÑ), Magnesiumnitrat (Mg(NO‚ÇÉ)‚ÇÇ), Magnesiumphosphat (Mg‚ÇÉ(PO‚ÇÑ)‚ÇÇ), Kaliumcarbid (K‚ÇÑC), Aluminiumnitrit (Al(NO‚ÇÇ)‚ÇÉ), Aluminiumphosphat (AlPO‚ÇÑ), Eisen(III)oxid (Fe‚ÇÇO‚ÇÉ), Eisen(II)oxid (FeO), Kupfer(II)oxid (CuO), Kupfer(I)oxid (Cu‚ÇÇO), Kaliumpermanganat (KMnO‚ÇÑ), Chrom(III)sulfat (Cr‚ÇÇ(SO‚ÇÑ)‚ÇÉ), Zink(II)carbonat (ZnCO‚ÇÉ), Natriumsulfit (Na‚ÇÇSO‚ÇÉ), Kaliumphosphit (K‚ÇÇSO‚ÇÉ)`,
            molecular: `Schwefeldioxid (SO‚ÇÇ), Schwefeltrioxid (SO‚ÇÉ), Kohlenstoffmonoxid (CO), Kohlenstoffdioxid (CO‚ÇÇ), Diphosphorpentaoxid (P‚ÇÇO‚ÇÖ), Chlordioxid (ClO‚ÇÇ), Distickstofftetraoxid (N‚ÇÇO‚ÇÑ), Distickstoffmonoxid (N‚ÇÇO), Stickstoffmonoxid (NO), Stickstoffdioxid (NO‚ÇÇ), Dichloromonoxid (Cl‚ÇÇO), Dichlorheptoxid (Cl‚ÇÇO‚Çá), Siliciumdioxid (SiO‚ÇÇ), Phosphortrichlorid (PCl‚ÇÉ), Phosphorpentachlorid (PCl‚ÇÖ), Schwefelhexafluorid (SF‚ÇÜ), Schwefeltetrachlorid (SCl‚ÇÑ), Kohlenstofftetrachlorid (CCl‚ÇÑ), Dibortrioxid (B‚ÇÇO‚ÇÉ), Arsentrioxid (As‚ÇÇO‚ÇÉ), Diiodpentaoxid (I‚ÇÇO‚ÇÖ), Xenondifluorid (XeF‚ÇÇ)`,
            acidsbases: `Salzs√§ure (HCl), Schwefels√§ure (H‚ÇÇSO‚ÇÑ), Phosphors√§ure (H‚ÇÉPO‚ÇÑ), Phosphorige S√§ure (H‚ÇÉPO‚ÇÉ), Schweflige S√§ure (H‚ÇÇSO‚ÇÉ), Kohlens√§ure (H‚ÇÇCO‚ÇÉ), Salpeters√§ure (HNO‚ÇÉ), Salpetrige S√§ure (HNO‚ÇÇ), Blaus√§ure (HCN), Essigs√§ure (CH‚ÇÉCOOH), Natriumhydroxid (NaOH), Ammoniak (NH‚ÇÉ), Calciumhydroxid (Ca(OH)‚ÇÇ), Kalkwasser (Ca(OH)‚ÇÇ), Kaliumhydroxid (KOH), Natronlauge (NaOH), Flusss√§ure (HF)`,
            organic: `Methan (CH‚ÇÑ), Ethan (C‚ÇÇH‚ÇÜ), Ethen (C‚ÇÇH‚ÇÑ), Ethin (C‚ÇÇH‚ÇÇ), Methanol (CH‚ÇÉOH), Ethanol (C‚ÇÇH‚ÇÖOH), Essigs√§ure (CH‚ÇÉCOOH), Propen (C‚ÇÉH‚ÇÜ), Propan (C‚ÇÉH‚Çà), But-1-in (C‚ÇÑH‚ÇÜ), Aceton (C‚ÇÉH‚ÇÜO), Acetaldehyd (C‚ÇÇH‚ÇÑO)`
         };

        // *** √úberarbeitete parseCompoundString Funktion ***
        function parseCompoundString(compoundString) {
            const compounds = [];
            const regex = /^(.*?)\s+\(([^()]+)\)$/;
            compoundString.split(',').forEach(part => {
                const trimmedPart = part.trim();
                if (trimmedPart) {
                    const match = trimmedPart.match(regex);
                    if (match && match[1] && match[2]) {
                        compounds.push({ name: match[1].trim(), formula: match[2].trim() });
                    } else {
                         const complexRegex = /^(.*?)\s+\((.*)\)$/;
                         const complexMatch = trimmedPart.match(complexRegex);
                         if (complexMatch && complexMatch[1] && complexMatch[2]) {
                              compounds.push({ name: complexMatch[1].trim(), formula: complexMatch[2].trim() });
                         } else { console.warn(`Konnte Teil nicht parsen (kein klares Format): "${trimmedPart}"`); }
                    }
                }
            });
            return compounds;
        }


        // --- Parsed Daten und Gesamtliste ---
        let parsedCompoundData = {}; let allParsedCompounds = []; let allFormulas = [];
        let dataInitializationError = false;

        // *** Initialisierungsfunktion mit Fehlerbehandlung ***
        function initializeCompoundData() {
             dataInitializationError = false;
             try {
                parsedCompoundData = {}; allParsedCompounds = []; allFormulas = [];
                for (const category in compoundData) {
                    if (compoundData.hasOwnProperty(category)) {
                        parsedCompoundData[category] = parseCompoundString(compoundData[category]);
                        allParsedCompounds = allParsedCompounds.concat(parsedCompoundData[category]);
                    }
                }
                const totalSourceEntries = Object.values(compoundData).reduce((sum, str) => sum + (str.split(',').filter(s => s.trim() !== '').length), 0);
                if(allParsedCompounds.length !== totalSourceEntries) {
                    console.warn(`Parsing Diskrepanz: ${totalSourceEntries} Eintr√§ge erwartet, ${allParsedCompounds.length} geparst.`);
                }

                allFormulas = [...new Set(allParsedCompounds.map(c => c.formula).concat([
                    "H‚ÇÇO", "O‚ÇÇ", "N‚ÇÇ", "H‚ÇÇ", "C‚ÇÜH‚ÇÅ‚ÇÇO‚ÇÜ", "FeCl‚ÇÇ", "AgNO‚ÇÉ", "H‚ÇÇO‚ÇÇ", "SO‚ÇÇ", "P‚ÇÑO‚ÇÅ‚ÇÄ", "NO‚ÇÇ"
                ]))];
                console.log("Verbindungsdaten initialisiert und geparst. Anzahl Verbindungen:", allParsedCompounds.length);
             } catch (error) {
                 dataInitializationError = true;
                 console.error("Fehler bei der Initialisierung der Verbindungsdaten:", error);
                 const errorMsgElement = document.getElementById('start-error-message');
                 if(errorMsgElement) {
                     errorMsgElement.textContent = "Fehler beim Laden der Chemiedaten. Bitte Code pr√ºfen.";
                     errorMsgElement.classList.remove('hidden');
                 }
             }
         }
        initializeCompoundData();

        // --- Spiel Zustand ---
        let players = []; let currentRound = 0; const totalRounds = 10; let currentSalt = null; let currentCardFormula = null; let cardVisible = false; let cardTimeout = null; let cardSequence = []; let cardSequenceIndex = 0; let gameActive = false; let grabCooldown = false; let roundSalts = [];
        let isSinglePlayer = false;

        // --- DOM Elemente ---
        const startScreen = document.getElementById('start-screen');
        const gameArea = document.getElementById('game-area');
        const saltNameDisplay = document.getElementById('salt-name-display');
        const handsContainer = document.getElementById('hands-container');
        const cardElement = document.getElementById('card');
        const roundDisplay = document.getElementById('round-display');
        const messageBox = document.getElementById('message-box');
        const endScreen = document.getElementById('end-screen');
        const podiumContainer = document.getElementById('podium-container');
        const singlePlayerResult = document.getElementById('single-player-result');
        const startErrorMessage = document.getElementById('start-error-message');

        // --- Hilfsfunktionen ---
        function shuffleArray(array) { for (let i = array.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [array[i], array[j]] = [array[j], array[i]]; } return array; }
        function showMessage(text, duration = 1000) { messageBox.textContent = text; messageBox.style.display = 'flex'; setTimeout(() => { messageBox.style.display = 'none'; }, duration); }
        function updateScores() { players.forEach(player => { const scoreElement = document.getElementById(`score-${player.id}`); if (scoreElement) { scoreElement.textContent = isSinglePlayer ? `Punkte: ${player.score}` : `P${player.id.substring(1)}: ${player.score}`; } }); }
        function updateRoundDisplay() { roundDisplay.textContent = `Runde: ${currentRound} / ${totalRounds}`; }

        // --- Spiel Logik ---
        function startGame(numPlayers) {
            console.log(`startGame(${numPlayers}) aufgerufen.`);
             if (dataInitializationError) { console.error("Spielstart verhindert, da Dateninitialisierung fehlgeschlagen ist."); return; }
            startErrorMessage.classList.add('hidden');
            const selectedCategories = []; const checkboxes = document.querySelectorAll('#topic-selection input[type="checkbox"]:checked'); checkboxes.forEach(checkbox => { selectedCategories.push(checkbox.value); }); console.log("Ausgew√§hlte Kategorien:", selectedCategories);
            if (selectedCategories.length === 0) { console.log("Keine Kategorie ausgew√§hlt."); startErrorMessage.textContent = "Bitte w√§hle mindestens ein Thema aus!"; startErrorMessage.classList.remove('hidden'); return; }
            let activeCompounds = []; selectedCategories.forEach(category => { if (parsedCompoundData[category]) { activeCompounds = activeCompounds.concat(parsedCompoundData[category]); } else { console.warn(`Kategorie "${category}" nicht in parsedCompoundData gefunden.`); } }); console.log("Anzahl aktiver Verbindungen:", activeCompounds.length);
             if (activeCompounds.length < totalRounds) { console.log("Nicht gen√ºgend Verbindungen."); startErrorMessage.textContent = `Nicht gen√ºgend Verbindungen (${activeCompounds.length}) f√ºr ${totalRounds} Runden in den gew√§hlten Themen. Bitte mehr Themen w√§hlen.`; startErrorMessage.classList.remove('hidden'); return; }
            console.log(`Starte Spiel mit ${numPlayers} Spielern und ${activeCompounds.length} aktiven Verbindungen.`); isSinglePlayer = (numPlayers === 1); startScreen.style.display = 'none'; gameArea.classList.remove('hidden'); players = []; currentRound = 0; gameActive = true; grabCooldown = false; handsContainer.innerHTML = ''; endScreen.style.display = 'none'; podiumContainer.style.display = 'none'; singlePlayerResult.style.display = 'none';
            const multiPlayerPositions = ['tl', 'tr', 'bl', 'br']; const handEmojis = ['‚úãüèª', '‚úãüèº', '‚úãüèΩ', '‚úãüèæ', '‚úãüèø'];
            if (isSinglePlayer) { const playerId = 'p1'; const position = 'single'; players.push({ id: playerId, score: 0, position: position }); const hand = document.createElement('div'); hand.id = playerId; hand.classList.add('hand', `hand-${position}`); hand.textContent = handEmojis[0]; hand.dataset.playerId = playerId; hand.addEventListener('touchstart', handleGrab, { passive: false }); hand.addEventListener('mousedown', handleGrab); handsContainer.appendChild(hand); const scoreElement = document.createElement('div'); scoreElement.id = `score-${playerId}`; scoreElement.classList.add('player-score', `score-${position}`); scoreElement.textContent = `Punkte: 0`; handsContainer.appendChild(scoreElement); }
            else { for (let i = 0; i < numPlayers; i++) { const playerId = `p${i + 1}`; const position = multiPlayerPositions[i]; players.push({ id: playerId, score: 0, position: position }); const hand = document.createElement('div'); hand.id = playerId; hand.classList.add('hand', `hand-${position}`); hand.textContent = handEmojis[i % handEmojis.length]; hand.dataset.playerId = playerId; hand.addEventListener('touchstart', handleGrab, { passive: false }); hand.addEventListener('mousedown', handleGrab); handsContainer.appendChild(hand); const scoreElement = document.createElement('div'); scoreElement.id = `score-${playerId}`; scoreElement.classList.add('player-score', `score-${position}`); scoreElement.textContent = `P${i + 1}: 0`; handsContainer.appendChild(scoreElement); } }
            roundSalts = shuffleArray([...activeCompounds]).slice(0, totalRounds); console.log("Runden-Verbindungen ausgew√§hlt:", roundSalts.length);
            console.log("Spiel initialisiert. Starte erste Runde."); setTimeout(nextRound, 500);
         }

        function nextRound() {
            if (!gameActive) return; currentRound++; console.log(`Starte Runde ${currentRound}`); updateRoundDisplay();
            if (currentRound > totalRounds) { endGame(); return; }
            if (!roundSalts || roundSalts.length === 0 || currentRound > roundSalts.length) { console.error("Fehler: Ung√ºltiger Zugriff auf roundSalts in nextRound."); gameActive = false; return; }
            currentSalt = roundSalts[currentRound - 1];
            if (!currentSalt) { console.error(`Fehler: Kein currentSalt f√ºr Runde ${currentRound} gefunden.`); gameActive = false; return; }
            saltNameDisplay.textContent = currentSalt.name; console.log(`Aktuelles Salz: ${currentSalt.name} (Formel: ${currentSalt.formula})`);
            cardSequence = generateCardSequence(currentSalt.formula); cardSequenceIndex = 0; cardVisible = false; cardElement.classList.remove('visible');
            console.log("Starte Karten-Zyklus..."); scheduleNextCard();
        }
        function generateCardSequence(correctFormula) {
            let sequence = [correctFormula]; let attempts = 0; const availableWrongFormulas = allFormulas.filter(f => f !== correctFormula);
            while (sequence.length < 5 && attempts < 100) { if (availableWrongFormulas.length === 0) break; const randomIndex = Math.floor(Math.random() * availableWrongFormulas.length); const randomFormula = availableWrongFormulas[randomIndex]; if (!sequence.includes(randomFormula)) { sequence.push(randomFormula); } attempts++; }
            while (sequence.length < 5 && availableWrongFormulas.length > 0) { const randomFormula = availableWrongFormulas[Math.floor(Math.random() * availableWrongFormulas.length)]; sequence.push(randomFormula); }
            while (sequence.length < 5) { sequence.push(correctFormula); } return shuffleArray(sequence);
        }
        function scheduleNextCard() {
            if (!gameActive || cardSequenceIndex >= cardSequence.length) { if (gameActive && cardSequenceIndex >= cardSequence.length) { console.log("Karten-Sequenz beendet, niemand hat richtig geraten."); setTimeout(nextRound, 500); } return; }
            if (cardVisible) { cardElement.classList.remove('visible'); cardVisible = false; currentCardFormula = null; cardTimeout = setTimeout(showCard, 1000); } else { showCard(); }
        }
        function showCard() {
            if (!gameActive || cardSequenceIndex >= cardSequence.length) return; currentCardFormula = cardSequence[cardSequenceIndex];
            const formattedFormula = currentCardFormula.replace(/(\d+)/g, '<sub>$1</sub>'); cardElement.innerHTML = formattedFormula;
            cardElement.classList.add('visible'); cardVisible = true; console.log(`Zeige Karte: ${currentCardFormula} (formatiert: ${formattedFormula})`);
            cardTimeout = setTimeout(() => { if (cardVisible) { cardElement.classList.remove('visible'); cardVisible = false; currentCardFormula = null; console.log("Karte ausgeblendet."); cardSequenceIndex++; scheduleNextCard(); } }, 3000);
        }

        // *** Angepasste handleGrab Funktion (Punktevergabe) ***
        function handleGrab(event) {
            event.preventDefault(); if (!gameActive || !cardVisible || grabCooldown) { console.log("Greifen nicht m√∂glich..."); return; } grabCooldown = true;
            const handElement = event.currentTarget; const playerId = handElement.dataset.playerId; const player = players.find(p => p.id === playerId); if (!player) return; console.log(`${playerId} versucht zu greifen: ${currentCardFormula}`); handElement.classList.add('grabbing');
            const correct = currentCardFormula === currentSalt.formula; cardElement.classList.remove('visible'); cardVisible = false; clearTimeout(cardTimeout);
            if (correct) {
                player.score += 1; // +1 Punkt
                showMessage("‚úÖ"); console.log(`${playerId} korrekt! Score: ${player.score}`); updateScores();
                setTimeout(() => { handElement.classList.remove('grabbing'); grabCooldown = false; nextRound(); }, 500);
            }
            else {
                player.score -= 1; // -1 Punkt
                showMessage("‚ùå"); console.log(`${playerId} falsch! Score: ${player.score}`); updateScores();
                setTimeout(() => { handElement.classList.remove('grabbing'); grabCooldown = false; cardSequenceIndex++; scheduleNextCard(); }, 500);
            }
        }
        function endGame() {
            console.log("Spielende!"); gameActive = false; clearTimeout(cardTimeout); cardElement.classList.remove('visible'); saltNameDisplay.textContent = "Spiel vorbei!";
            if (isSinglePlayer) { const finalScore = players[0].score; singlePlayerResult.textContent = `Dein Ergebnis: ${finalScore} Punkte`; singlePlayerResult.style.display = 'block'; podiumContainer.style.display = 'none'; endScreen.querySelector('h2').textContent = "Spiel beendet!"; }
            else { endScreen.querySelector('h2').textContent = "And the winner is‚Ä¶"; podiumContainer.style.display = 'flex'; singlePlayerResult.style.display = 'none'; players.sort((a, b) => b.score - a.score); let rank = 0; let lastScore = Infinity; let playersWithRank = []; players.forEach((player, index) => { if (player.score < lastScore) { rank = index + 1; } if (rank <= 3) { playersWithRank.push({ player: player, rank: rank }); } lastScore = player.score; }); podiumContainer.innerHTML = ''; const podiumSlots = [null, null, null]; playersWithRank.forEach(item => { const player = item.player; const currentRank = item.rank; const placeDiv = document.createElement('div'); placeDiv.classList.add('podium-place', `podium-rank-${currentRank}`); if (currentRank === 1) { const crownSpan = document.createElement('span'); crownSpan.classList.add('crown'); crownSpan.textContent = 'üëë'; placeDiv.appendChild(crownSpan); } const nameSpan = document.createElement('span'); nameSpan.classList.add('player-name'); nameSpan.textContent = `Spieler ${player.id.substring(1)}`; placeDiv.appendChild(nameSpan); const scoreSpan = document.createElement('span'); scoreSpan.classList.add('player-score-final'); scoreSpan.textContent = `${player.score} Punkte`; placeDiv.appendChild(scoreSpan); if (currentRank === 1) podiumSlots[1] = placeDiv; else if (currentRank === 2) podiumSlots[0] = placeDiv; else if (currentRank === 3) podiumSlots[2] = placeDiv; }); podiumSlots.forEach((slot, index) => { if (slot) { podiumContainer.appendChild(slot); } else { const emptyDiv = document.createElement('div'); if (index === 0) emptyDiv.classList.add('podium-place', 'podium-rank-2', 'podium-empty'); else if (index === 1) emptyDiv.classList.add('podium-place', 'podium-rank-1', 'podium-empty'); else if (index === 2) emptyDiv.classList.add('podium-place', 'podium-rank-3', 'podium-empty'); podiumContainer.appendChild(emptyDiv); } }); }
            gameArea.classList.add('hidden'); endScreen.style.display = 'flex';
        }
        function restartGame() {
            console.log("Neustart des Spiels."); endScreen.style.display = 'none'; startScreen.style.display = 'flex'; startErrorMessage.classList.add('hidden');
        }
        document.body.addEventListener('touchmove', function(event) { if (gameActive) { event.preventDefault(); } }, { passive: false });

    </script>

</body>
</html>
